2013-10-12 
	关于角色数据的计算、优化
	像d2，角色各种属性之间形成了网状关系，那么当某一个/多个节点发生变化的时候，该如何更新与之相关的数据网呢？
	一开始我认为这种关系和树形结构类似，所以我打算从位于根节点的属性开始计算，沿着树形结构逐节点向着末端推进计算。
	比如假设每升一级加一点vit以及2life，而每点vit又加3life，而且升级还会增加AR，按照我一开始的思路，我会这么写
	function setLv(lv)
	{
		//赋值
		_lv = lv;
		
		//更新（直接子节点）数据
		updateVit();
		updateLife();
		updateAR();
		....
	}
	
	function updateVit()
	{
		_vit = _basicVit + _lv * 1;
		
		updateLife();
	}
	
	function updateLife()
	{
		_life = _basicLife + _lv * 2 + _vit * 3;
	}
	
	function updateAR()
	{
		......
	}
	
	这个实现，各种计算步骤要与网状关系同步维护，  随着网状关系变得复杂，计算步骤也会变得庞大，难以维护，而且从对updateLife的调用可以看出，存在很多重复操作。总的来说是不好的。
	然后我发现，这个关系网的连锁计算很像mvc模式中数据源的变化导致视图更新显示这一行为，于是我想到了用invalidate机制来优化网状结构的更新计算：
	基本思路：整个关系网可以分为许多条计算链路，一个节点至少会影响一条链路； 但是当任何一个节点发生变化后，并不马上重算其相关链路，而是做下“某链路需要更新计算”这一标记，等到下一更新时间点（比如invalidate之后的RENDER事件时）再做计算。 这样两次更新时间点之间，不论有多少节点发生多少次变化，其相关链路都只计算一次。
	最粗糙的实现就是整个关系网当做一条链路看待，不做细分。就像用一个ChangeEvent去驱动视图重绘所有元素一样（该元素实际上有没有发生变化）。根据场合，这种牺牲部分时间换取结构简单的做法是可以接受的。
	
	关于设计结构：计算公式与数据对象	根据我使用3dmax时对其设计模式的理解和习惯，数据对象只存放数据，对数据的修改则通过(3dmax)修改器，时间轴曲线等其他类、对象来操作
	
2013-10-14
	invalidate这个函数释义不明确，也许可以叫callTick(), regTick(), autoNextTick等等

	以力量为例，一个角色的力量计算公式为
	str = 初始str + 配点str + str加成 + str百分比加成
	
	为了图省事，没写成员属性的getter
	
2013-10-16
	更新链路的算法，每个节点的setter函数会修改节点值，注册失效，然后激活其直属节点的重算，其直属节点继续激活下一个直属节点，如此连锁激活直到数据网的末梢。
	失效机制将会导致TickMgr在下一计算帧开始时执行注册者的
	在这个设计中，节点分成两种，一种是可直接修改节点，一种是非直接修改节点。
	前者通常是最底端的原子节点，需要配备setter函数，后者只通过toRecal函数来schedule重算
	
2013-10-17
	尝试了一下上面算法，用手动的办法激活直属节点(参见  手动链接激活直属节点计算链 目录 )。我又想到了可以把节点封装一下，让它们可以在设置好关系之后自动发生连锁激活。

2013-10-19
	推演了一下封装节点的做法，感觉不适用：实现麻烦，使用起来不直观，调试的时候可能也麻烦。于是还是先用上面的手动激活方法继续写吧。

2013-10-20
	buff和技能的配置数据放在哪里？ 这些东西有个特点：经常会调整。
	最直接的做法，我们可以写死在代码里，优点是结构简单，能实现的功能最全；缺点是不便更新，每次修改都必须重新编译。
	从解决这个缺点出发，我们把一些配置数据从程序代码中移动到外部配置文件。有两种做法，一种用配置数据，另一种就是用脚本。
	配置数据适用于规则闭合的场合，比如各种模板数据
	脚本适用于规则开放的场合，比如技能，其实很多东西都可以用脚本来实现。

2013-10-22
	代码在什么情况下放在什么位置？自身？跨域？按照我的地区-中央政区模型，这应该是由代码涉及的政区所决定的。地方政府就可以解决的自然放在地方解决，需要跨地区解决的那就放在跨域管理器中呗。

2013-10-24 
	关于道具系统的设计
	道具的分类有很多种，功能和用法也不尽相同，有提供数值加成的，有用作消耗品、材料的，有可以主动点击使用触发技能或者什么东西的。虽然看上去都是道具图标，但是背后的机制不一样
	
	列出几个例子
	1 装备  武器提供攻击力，防具提供防御力，坐骑提供移动加成，并且还要修改角色的外观
	2 血瓶	使用血瓶其实是触发【喝血】这个技能，然后根据使用血瓶的数据，计算消耗多少血瓶，回复多少血
	3 材料	本省不能主动使用，在使用某些技能时需要扣除足够数量的材料
	4 炸弹	其实是触发【投掷炸弹】这个技能
	背包，钥匙，等等，好多好多

	当用户试图使用某道具时，系统需要根据道具的类型来执行对应的操作。

	关于装备，初步对其常见数据划分如下
	1 需求数据	比如属性、等级、职业需求
	2 功效数据	某类道具的专门效果，比如武器所增加的攻击力数值，防具所增加的防御力数值
	3 额外效果	比如装备某道具（在功效数据之外）额外提供的数值加成，在d2中是用【词缀】系统来实现的

2013-11-3
	关于技能的实现
	一个技能的使用过程，可能会很复杂，不妨举个例子，比如火球术攻击，它的流程如下
	
	【火球术】需要两个参与者，一个是施法者，一个是攻击目标。
	用户先选择施法者，在ui上点击【火球术】图标，然后选择攻击目标， 通常鼠标会变成另一个样式，标示程序已经进入【目标选择】模式。（也可能是先选择攻击目标，然后再施法，比如wow）

	第一步 施法（前置）条件检定
	施法者检定
		施法者的【火球术】未在cd中
		有足够的魔法值
		有足够的施法材料，假如火球术需要施法材料的话
		处于可以施法的状态：站立、非眩晕、非死亡、非禁言...等等
	攻击目标检定
		是合法的目标类型
		处于可被火球术攻击的状态：比如没有处于【魔法免疫】状态
	综合检定
		施法者与攻击者之间的距离在【火球术】的攻击范围之内
		施法者与攻击者之间没有能够阻挡【火球术】的障碍物
		其他时间，地点等各种其他条件...

	* 可以看出技能管理器可能需要调用任意可能性的游戏数据，因此它必须拥有很高跨域权限
	* 常见的设定还有：如果目标不在攻击范围内，向目标移动直至其进入攻击范围。

	第二步 准备施法：前置动作
	开始“搓火球”读条

	第三步 施法：播放施法动作
	“搓火球”读条结束后，客户端开始播放施法动作，播放到【施法关键帧】时，向目标发射一个火球对象。
	【火球术】技能开始cd
	扣除对应的魔法值和消耗材料
	* 引导型的魔法则让施法者进入【引导】状态

	第四步 命中及效果计算
	当火球撞到目标时，首先进行命中检定
	通常会依次检查
		目标是否有格挡？
		目标是否有闪避？
		目标是否有反弹火球?
		火球是否打偏了目标？
	火球命中了目标则进行效果处理，比如
		法术伤害
		火焰伤害
		给目标上某buff
		调用【范围爆炸】技能


	至此，使用【火球术】的一个完整流程结束
	这一套流程在单机和服务端实现的时候会根据各自的技术环境进行筛选和调整，比如客户端可能是真的实时计算火球飞行中的碰撞，而服务器可能只是根据施法者与攻击者之间的距离做个命中倒计时而已。
	【物理攻击】【瞬发法术】等其他技能，或简或繁，都可以参照上述流程进行实现。





	关于修改器	buff 
	状态机


	




